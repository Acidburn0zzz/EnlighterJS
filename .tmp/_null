/*! EnlighterJS Syntax Highlighter 2.7.0 | MIT License (X11) | http://enlighterjs.andidittrich.de/ | June 20 2015 */
(function() {
    /*!
---
name: GitHub-Buttons for MooTools, jQuery and PHP
description: Unofficial GitHub Buttons based on https://github.com/mdo/github-buttons

license: Apache 2.0 License
version: 2.5.0
build: 54ff1b657e537f8107ee7373e0bfeeeb/May 6 2015

authors:
  - Andi Dittrich (author of MooTools/jQuery/PHP based versions)
  - Mark Otto (author of original github-buttons styles)
  
download: https://github.com/AndiDittrich/MooTools.GitHub-Buttons
website: http://github-buttons.andidittrich.de
demo: http://github-buttons.andidittrich.de
  
requires:
  - Core/1.4.5
  - More/Number.Format
  - More/Request.JSONP

provides: [GitHubButton]
...
*/
    /*
---
name: GitHub-Buttons
description: Unofficial GitHub Buttons inspired by https://github.com/mdo/github-buttons

license: Dual-Licensed under "The MIT License (X11)" and "Apache 2.0 License"

authors:
  - Andi Dittrich
  
requires:
  - Core/1.4.5
  - More/Number.Format
  - More/Request.JSONP

provides: [GitHubButton]
...
 */
    var GitHubButton = new Class({
        Implements: Options,
        // contains the required html structure
        buttonContainer: null,
        options: {
            // large or small button ?
            large: false,
            // GitHub username
            owner: null,
            // GitHub repository name
            repo: null,
            // Button type (star, fork, watch, follow)
            type: "star",
            // custom button text
            text: null,
            // enabled/disable counter - manual set the value
            count: true,
            // enable/disable caching
            cache: true,
            // cache lifetime in seconds (2h default)
            cacheLifetime: 7200,
            // error text/count
            errorText: "NA"
        },
        initialize: function(options) {
            this.setOptions(options);
            // jsonp rest service url
            var url = "https://api.github.com";
            // create repo url
            var repoUrl = "https://github.com/" + this.options.owner + "/" + this.options.repo + "/";
            var actionUrl = "https://github.com/" + this.options.owner + "/";
            // text to display
            var text = "-";
            // response object selector
            var responseSelector = "";
            // star, fork, follow, watch are supported
            switch (this.options.type) {
              case "star":
                url += "/repos/" + this.options.owner + "/" + this.options.repo;
                text = "Star";
                actionUrl = repoUrl + "stargazers";
                responseSelector = "stargazers_count";
                break;

              case "fork":
                url += "/repos/" + this.options.owner + "/" + this.options.repo;
                text = "Fork";
                actionUrl = repoUrl + "network";
                responseSelector = "forks_count";
                break;

              case "watch":
                url += "/repos/" + this.options.owner + "/" + this.options.repo;
                actionUrl += this.options.repo + "/watchers";
                text = "Watchers";
                responseSelector = "subscribers_count";
                break;

              case "follow":
                url += "/users/" + this.options.owner;
                text = "Follow @" + this.options.owner;
                repoUrl = actionUrl;
                actionUrl += "followers";
                responseSelector = "followers";
                break;
            }
            // create html structure
            // @see https://github.com/mdo/github-buttons/blob/master/github-btn.source.html
            // <span class="github-btn" id="github-btn">
            //  <a class="gh-btn" id="gh-btn" href="#" target="_blank">
            //    <span class="gh-ico"></span>
            //    <span class="gh-text" id="gh-text"></span>
            //  </a>
            //  <a class="gh-count" id="gh-count" href="#" target="_blank"></a>
            // </span>
            // create elements
            this.buttonContainer = new Element("div", {
                "class": "github-btn " + (this.options.large ? "github-btn-large" : "")
            });
            var count = new Element("a", {
                "class": "gh-count",
                href: actionUrl,
                target: "_blank"
            });
            var ico = new Element("span", {
                "class": "gh-ico"
            });
            var txt = new Element("span", {
                "class": "gh-text",
                text: this.options.text ? this.options.text : text
            });
            var button = new Element("a", {
                "class": "gh-btn",
                href: repoUrl,
                target: "_blank"
            });
            // create structure
            button.grab(ico).grab(txt);
            this.buttonContainer.grab(button).grab(count);
            // which "count"-mode should be used ?
            if (typeof this.options.count == "boolean") {
                // show count and request the data via JSONP ?
                if (this.options.count) {
                    // cache instance name
                    var cacheName = "GHB_" + this.options.type + "_" + this.options.owner + "_" + this.options.repo + "_" + responseSelector;
                    // cache version available ?
                    if (this.options.cache === true) {
                        var cdata = this.retrieveItem(cacheName, this.options.cacheLifetime);
                        if (cdata) {
                            // update text
                            count.set("text", cdata.format({
                                group: "."
                            }));
                            return;
                        }
                    }
                    // request data
                    new Request.JSONP({
                        // the rest service url
                        url: url,
                        // jsonp callback get parameter
                        // @see https://developer.github.com/v3/#json-p-callbacks
                        callbackKey: "callback",
                        // request complete handler
                        onComplete: function(response) {
                            // valid reponse ? request limit not exceeeded ?
                            if (response.data && response.data[responseSelector]) {
                                // extract count
                                var cnt = response.data[responseSelector];
                                // update text
                                count.set("text", cnt.format({
                                    group: "."
                                }));
                                // update cache
                                if (this.options.cache === true) {
                                    this.storeItem(cacheName, cnt);
                                }
                            } else {
                                count.set("text", this.options.errorText);
                            }
                        }.bind(this)
                    }).send();
                } else {
                    // hide counter
                    count.setStyle("display", "none");
                }
            } else {
                // manually set the value
                count.set("text", this.options.count.format({
                    group: "."
                }));
            }
        },
        // magic method to use class instance as element
        toElement: function() {
            return this.buttonContainer;
        },
        // use local storage as cache
        storeItem: function(name, data) {
            // generate storage data
            var d = JSON.encode({
                time: new Date().getTime(),
                payload: data
            });
            // try to use html5 features
            if (typeof Storage !== "undefined") {
                localStorage.setItem(name, d);
            }
        },
        // use local storage as cache
        retrieveItem: function(name, cacheLifetime) {
            // try to use html5 features
            if (typeof Storage !== "undefined") {
                // get item
                var ls = localStorage.getItem(name);
                // available ?
                if (!ls) {
                    return null;
                }
                // decode json serialized data
                ls = JSON.decode(ls);
                // lifetime expired ?
                if (!ls.time || ls.time + cacheLifetime * 1e3 < new Date().getTime()) {
                    return null;
                }
                // valid payload ?
                return ls.payload ? ls.payload : null;
            } else {
                return null;
            }
        }
    });
    // Native Element extension - jQuery like usage
    (function() {
        Element.implement({
            GitHubButton: function(options) {
                this.grab(new GitHubButton(options));
            }
        });
    })();
    var HyperCoreJS = {
        Modules: {}
    };
    function ContentNavigation(contentContainerSelector, navContainerSelector) {
        // content navi
        var nav = document.getElement(navContainerSelector);
        if (!nav || nav.get("data-autogen") !== "true") {
            return;
        }
        // get the content container
        var contentContainer = document.getElement(contentContainerSelector);
        // container offset (absolute position)
        var containerOffset = contentContainer.getPosition().y;
        // the current subsection
        var currentSection = null;
        // unique heading id
        var headingID = 1;
        // scroll spy observer
        var h2Observer = {
            elements: [],
            currentAnchor: null,
            currentItem: null
        };
        var h3Observer = {
            elements: [],
            currentAnchor: null,
            currentItem: null
        };
        // get all h2, h3 elements
        contentContainer.getElements("h2, h3").each(function(el) {
            // create anchor name
            var anchorName = el.get("text").replace(/\s+?/gi, "_").replace(/[^a-z0-9_ -]/gi, "") + "_" + headingID;
            // add invisible anchor
            var anchor = new Element("span", {
                "class": "anchor",
                id: anchorName
            });
            el.grab(anchor, "before");
            // generate navigation
            if (el.tagName == "H3" && currentSection) {
                var h3 = new Element("li");
                h3.grab(new Element("a", {
                    text: el.get("text"),
                    href: "#" + anchorName
                }));
                currentSection.grab(h3);
            } else if (el.tagName == "H2") {
                var h2 = new Element("li");
                h2.grab(new Element("a", {
                    text: el.get("text"),
                    href: "#" + anchorName
                }));
                // open new section
                currentSection = new Element("ul");
                h2.grab(currentSection);
                nav.grab(h2);
            }
            // scroll spy observer
            (el.tagName == "H3" ? h3Observer : h2Observer).elements.push({
                id: anchorName,
                position: el.getPosition()
            });
            // increment id
            headingID++;
        });
        // sort observers by position
        h2Observer.elements.sort(function(a, b) {
            return a.position.y - b.position.y;
        });
        h3Observer.elements.sort(function(a, b) {
            return a.position.y - b.position.y;
        });
        // add dummy elements (max position)
        h2Observer.elements.push({
            position: {
                y: 9999999,
                x: 999999
            }
        });
        h3Observer.elements.push({
            position: {
                y: 9999999,
                x: 999999
            }
        });
        window.addEvent("scroll", function() {
            // current scroll with calculated offset
            var currentWindowScroll = window.getScroll().y + containerOffset;
            // update h2 & h3 elements
            Array.each([ h2Observer, h3Observer ], function(observer) {
                // find currently visible element
                for (var i = 0; i < observer.elements.length; i++) {
                    // element visible ?
                    if (observer.elements[i].position.y > currentWindowScroll) {
                        // the n-1th element is the currently active one
                        if (i > 0) {
                            i = i - 1;
                        }
                        // element changed ?
                        if (observer.currentAnchor != observer.elements[i].id) {
                            // store current anchorID
                            observer.currentAnchor = observer.elements[i].id;
                            // old highlighted menu item available ?
                            if (observer.currentItem) {
                                observer.currentItem.removeClass("spyActive");
                            }
                            // get new menu item to highlight by it's anchor link (get it's parent li container !)
                            observer.currentItem = nav.getElement('a[href="#' + observer.currentAnchor + '"]').getParent();
                            // highlight element
                            if (observer.currentItem) {
                                observer.currentItem.addClass("spyActive");
                            }
                        }
                        break;
                    }
                }
            });
        }).fireEvent("scroll");
    }
    function ScrollSpyNavigation(navContainerSelector, contentContainerSelector) {}
    function StickyNavigation(navContainerSelector) {
        // navi container element
        var naviContainer = document.getElement(navContainerSelector);
        // container available ?
        if (!naviContainer) {
            return;
        }
        // initial scroll offset
        // get absolute container position
        var scrollLimit = naviContainer.getPosition().y;
        // get fixed position and use this value as offset
        naviContainer.addClass("fixedPosition");
        scrollLimit = scrollLimit - naviContainer.getStyle("top").toInt();
        naviContainer.removeClass("fixedPosition");
        // fixed sidebar
        window.addEvent("scroll", function() {
            if (this.getScroll().y > scrollLimit) {
                naviContainer.addClass("fixedPosition");
            } else {
                naviContainer.removeClass("fixedPosition");
            }
        });
    }
    window.addEvent("domready", function() {
        // create github buttons
        document.id("ghb").grab(new GitHubButton({
            owner: "AndiDittrich",
            repo: "EnlighterJS",
            large: false,
            type: "star"
        })).grab(new GitHubButton({
            owner: "AndiDittrich",
            repo: "EnlighterJS",
            large: false,
            type: "fork"
        })).grab(new GitHubButton({
            owner: "AndiDittrich",
            repo: "EnlighterJS",
            large: false,
            type: "follow"
        }));
        // initialize content navigation
        ContentNavigation("article", "#content-nav");
        // initialize sticky nav
        StickyNavigation("#content-nav");
    });
})();